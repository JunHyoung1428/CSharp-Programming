using System.Drawing;
using System.Reflection.Metadata;

namespace _09.OOP
{
    // <<<<<객체 지향 프로그래밍>>>>>>>
    // 프로그램을 서로 상호작용하는 객체를 기본 단위로 구성


    /* 객체 지향의 장단점
     * 장점:  1.객체단위로 관리하기 때문에 디버깅이 유리함
     *        2.클래스 단위로 모듈화 시켜 관리하므로 대규모 프로젝트에 적합ㅂ
     *        3.코드의 재사용성이 좋음
     *        
     * 단점:  1. 설계에 시간이 많이 소비되며 신중해야함
     */

    /* *********************************************************************************************
     * 객체 지향의 4가지 특징
     * 캡슐화 : 객체를 상태와 기능으로 묶는 것을 의미하며, 객체의 내부 상태와 기능을 숨기고, 허용한 상태와 기능의 엑세스만을 허용
     * 다형성 : 부모클래스의 함수를 자식클래스에서 재정의하여 다른 반응을 구현                     ex=> 스킬이란 부모클래스를 만들고 자식클래스에서 재정의하여 여러가지 스킬들의 동작을 구현
     * 추상화 : 관련 특성 및 엔티티의 상호작용을 클래스로 모델링하여 시스템의 추상적 표현을 정의   ex=> 향후 몬스터 추가를 위해 몬스터 클래스를 추상화로 선언
     * 상속   : 부모클래스의 모든 기능을 가지는 자식클래스를 설계하는 방법
     ***********************************************************************************************/

    /*******************************************************************************************************************
     *              <객체설계 5원칙>
     * S 단일  책임 원칙 - 객체는 오직 하나의 책임만을 가져야함
     * O 개방  폐쇄 원칙 - 확장에 대해서는 개방적, 수정에 대해서는 폐쇄적
     * L 리스코프 치환  원칙 - 자식클래스는 언제나 자신의 부모클래스를 대체 할 수 있어야함
     * I 인터페이스 분리  원칙 - 작은 단위들로 분리시켜 인터페이스를 구현, 사용하지 않는 함수는 포함하지 않아야함
     * D 의존성 역전  윈칙 - 객체는 하위클래스(상위클래스를 구현한 객체) 보다 상위클래스(추상성이 높은 클래스)에 의존해야함
     **********************************************************************************************************************/

    class Player
    {
        public int hp = 100;

        public void Use(Potion potion)
        {
            potion.Use(this);
        }
    }

    class Potion
    {
        public int healRate = 10;

        public void Use(Player player)
        {
            player.hp += healRate;
        }
    }
    internal class Program
    {
        static void Main2(string[] args)
        {
            Player player = new Player();
            Potion potion = new Potion();

            player.Use(potion);
        }
    }
}
